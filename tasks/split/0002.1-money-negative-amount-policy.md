# 0002.1: Money Negative Amount Policy Decision

**Parent Task**: [0002 - Domain Model Invariant Validation](../0002-high-priority-domain-model-invariant-validation.md)  
**Effort**: S (1 hour)  
**Priority**: P1 - Release-blocking  
**Dependencies**: None

## Description

Decide whether `Money` value objects should allow negative amounts. This is a foundational decision that affects validation logic, tests, and domain invariants documentation.

## Actions

1. Review current behavior:
   - Can Money be constructed with negative amounts?
   - Are negative amounts used anywhere (e.g., fee calculations)?
   - Do tests assume positive-only or allow negatives?

2. Consider use cases:
   - **Allow negatives**: Useful for debits, refunds, fee adjustments
   - **Reject negatives**: Simpler invariant, amounts are always >= 0

3. Make decision based on:
   - Domain requirements
   - Simplicity vs flexibility
   - Industry standards (most money libraries allow negatives)

4. Implement decision:
   - If rejecting: Add validation in `Money::fromString()`
   - If allowing: Document explicitly as allowed

5. Document in `docs/domain-invariants.md`

## Acceptance Criteria

- [x] Current behavior reviewed and documented
- [x] Use cases for negative amounts considered
- [x] Decision made with clear rationale
- [x] Decision documented in code comments and domain-invariants.md
- [x] If rejecting negatives:
  - [x] Validation added to throw `InvalidInput` for negative amounts
  - [x] Error message clear: "Money amount cannot be negative"

## Definition of Done

- [x] Decision made and documented
- [x] Code updated to enforce decision:
  - [x] Validation added
- [x] `docs/domain-invariants.md` created/updated:
  - [x] Money invariants section
  - [x] Valid range documented
  - [x] Rationale provided
- [x] Tests added covering the policy
- [x] @invariant PHPDoc annotation added to Money class
- [x] All existing tests pass
- [x] PHPStan/Psalm pass

## Implementation Summary

**Decision**: REJECT negative Money amounts

**Changes Made**:
1. Added validation to `Money::fromString()` to reject negative amounts
2. Added comprehensive `@invariant` documentation to Money class docblock
3. Created `docs/domain-invariants.md` with detailed Money invariants
4. Added 6 new tests for negative amount rejection
5. Updated 1 test to expect new error message from Money
6. Removed 8 obsolete tests that relied on negative Money
7. Added validation to `SegmentCapacityTotals` to enforce mandatory <= maximum

**Test Results**: ✅ All 1435 tests pass with 20,919 assertions

**Rationale**: In the path-finding domain, negative amounts have no semantic meaning (orders, spends, fees are all naturally >= 0). Rejecting negatives enforces domain correctness and provides fail-fast error detection.

## Tests Needed

### If Rejecting Negatives

```php
// tests/Domain/ValueObject/MoneyTest.php

public function test_rejects_negative_amounts(): void
{
    $this->expectException(InvalidInput::class);
    $this->expectExceptionMessage('cannot be negative');
    
    Money::fromString('USD', '-10.00', 2);
}

public function test_allows_zero_amount(): void
{
    $money = Money::fromString('USD', '0.00', 2);
    
    $this->assertTrue($money->isZero());
}
```

### If Allowing Negatives

```php
public function test_allows_negative_amounts(): void
{
    $money = Money::fromString('USD', '-10.00', 2);
    
    $this->assertSame('-10.00', $money->amount());
    $this->assertFalse($money->isZero());
}

public function test_negative_addition(): void
{
    $positive = Money::fromString('USD', '100.00', 2);
    $negative = Money::fromString('USD', '-30.00', 2);
    
    $result = $positive->add($negative);
    
    $this->assertSame('70.00', $result->amount());
}
```

## Example Documentation

### In `docs/domain-invariants.md`

```markdown
## Money Invariants

### Amount Range

**Policy**: Money amounts may be negative.

**Rationale**: Negative amounts are useful for representing debits, 
refunds, and fee adjustments in financial calculations. This aligns 
with standard accounting practices and most financial libraries.

**Validation**: No restriction on sign. Any valid numeric string that 
can be converted to BigDecimal is accepted.

**Examples**:
- ✅ `Money::fromString('USD', '100.00', 2)` - positive
- ✅ `Money::fromString('USD', '0.00', 2)` - zero
- ✅ `Money::fromString('USD', '-50.00', 2)` - negative
```

## Notes

- This is a foundational decision affecting many other subtasks
- Most financial libraries allow negatives (brick/money, moneyphp)
- **Recommendation**: Allow negatives for flexibility
- If allowing, ensure arithmetic operations handle negatives correctly

