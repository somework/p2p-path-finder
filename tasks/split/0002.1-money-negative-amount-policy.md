# 0002.1: Money Negative Amount Policy Decision

**Parent Task**: [0002 - Domain Model Invariant Validation](../0002-high-priority-domain-model-invariant-validation.md)  
**Effort**: S (1 hour)  
**Priority**: P1 - Release-blocking  
**Dependencies**: None

## Description

Decide whether `Money` value objects should allow negative amounts. This is a foundational decision that affects validation logic, tests, and domain invariants documentation.

## Actions

1. Review current behavior:
   - Can Money be constructed with negative amounts?
   - Are negative amounts used anywhere (e.g., fee calculations)?
   - Do tests assume positive-only or allow negatives?

2. Consider use cases:
   - **Allow negatives**: Useful for debits, refunds, fee adjustments
   - **Reject negatives**: Simpler invariant, amounts are always >= 0

3. Make decision based on:
   - Domain requirements
   - Simplicity vs flexibility
   - Industry standards (most money libraries allow negatives)

4. Implement decision:
   - If rejecting: Add validation in `Money::fromString()`
   - If allowing: Document explicitly as allowed

5. Document in `docs/domain-invariants.md`

## Acceptance Criteria

- [ ] Current behavior reviewed and documented
- [ ] Use cases for negative amounts considered
- [ ] Decision made with clear rationale
- [ ] Decision documented in code comments and domain-invariants.md
- [ ] If rejecting negatives:
  - Validation added to throw `InvalidInput` for negative amounts
  - Error message clear: "Money amount cannot be negative"
- [ ] If allowing negatives:
  - Explicitly documented as allowed behavior
  - @invariant annotation states range: "amount can be any valid BigDecimal"

## Definition of Done

- [ ] Decision made and documented
- [ ] Code updated to enforce decision:
  - Validation added OR
  - Documentation clarified
- [ ] `docs/domain-invariants.md` created/updated:
  - Money invariants section
  - Valid range documented
  - Rationale provided
- [ ] Tests added covering the policy
- [ ] @invariant PHPDoc annotation added to Money class
- [ ] All existing tests pass
- [ ] PHPStan/Psalm pass

## Tests Needed

### If Rejecting Negatives

```php
// tests/Domain/ValueObject/MoneyTest.php

public function test_rejects_negative_amounts(): void
{
    $this->expectException(InvalidInput::class);
    $this->expectExceptionMessage('cannot be negative');
    
    Money::fromString('USD', '-10.00', 2);
}

public function test_allows_zero_amount(): void
{
    $money = Money::fromString('USD', '0.00', 2);
    
    $this->assertTrue($money->isZero());
}
```

### If Allowing Negatives

```php
public function test_allows_negative_amounts(): void
{
    $money = Money::fromString('USD', '-10.00', 2);
    
    $this->assertSame('-10.00', $money->amount());
    $this->assertFalse($money->isZero());
}

public function test_negative_addition(): void
{
    $positive = Money::fromString('USD', '100.00', 2);
    $negative = Money::fromString('USD', '-30.00', 2);
    
    $result = $positive->add($negative);
    
    $this->assertSame('70.00', $result->amount());
}
```

## Example Documentation

### In `docs/domain-invariants.md`

```markdown
## Money Invariants

### Amount Range

**Policy**: Money amounts may be negative.

**Rationale**: Negative amounts are useful for representing debits, 
refunds, and fee adjustments in financial calculations. This aligns 
with standard accounting practices and most financial libraries.

**Validation**: No restriction on sign. Any valid numeric string that 
can be converted to BigDecimal is accepted.

**Examples**:
- ✅ `Money::fromString('USD', '100.00', 2)` - positive
- ✅ `Money::fromString('USD', '0.00', 2)` - zero
- ✅ `Money::fromString('USD', '-50.00', 2)` - negative
```

## Notes

- This is a foundational decision affecting many other subtasks
- Most financial libraries allow negatives (brick/money, moneyphp)
- **Recommendation**: Allow negatives for flexibility
- If allowing, ensure arithmetic operations handle negatives correctly

