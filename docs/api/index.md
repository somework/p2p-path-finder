# API Documentation

This file is generated by `bin/generate-phpdoc.php` and summarises the available public APIs.

## SomeWork\P2PPathFinder\Application\Order\Filter\CurrencyPairFilter
Accepts orders that match an exact asset pair.

### Public methods

### __construct
`CurrencyPairFilter::__construct(SomeWork\P2PPathFinder\Domain\Money\AssetPair $assetPair)`

### accepts
`CurrencyPairFilter::accepts(SomeWork\P2PPathFinder\Domain\Order\Order $order): bool`

## SomeWork\P2PPathFinder\Application\Order\Filter\MaximumAmountFilter
Accepts orders whose maximum fill amount does not exceed the configured threshold.

### Public methods

### __construct
`MaximumAmountFilter::__construct(SomeWork\P2PPathFinder\Domain\Money\Money $amount)`

### accepts
`MaximumAmountFilter::accepts(SomeWork\P2PPathFinder\Domain\Order\Order $order): bool`

## SomeWork\P2PPathFinder\Application\Order\Filter\MinimumAmountFilter
Accepts orders whose minimum fill amount does not exceed the configured threshold.

### Public methods

### __construct
`MinimumAmountFilter::__construct(SomeWork\P2PPathFinder\Domain\Money\Money $amount)`

### accepts
`MinimumAmountFilter::accepts(SomeWork\P2PPathFinder\Domain\Order\Order $order): bool`

## SomeWork\P2PPathFinder\Application\Order\Filter\ToleranceWindowFilter
Accepts orders whose effective rates fall within a tolerance window around a reference rate.

### Public methods

### __construct
`ToleranceWindowFilter::__construct(SomeWork\P2PPathFinder\Domain\Money\ExchangeRate $referenceRate, string $tolerance)`

Parameter $tolerance: numeric-string

### accepts
`ToleranceWindowFilter::accepts(SomeWork\P2PPathFinder\Domain\Order\Order $order): bool`

## SomeWork\P2PPathFinder\Application\PathSearch\Api\Request\PathSearchRequest
Immutable request DTO carrying the dependencies required to run a path search.

### Public methods

### __construct
`PathSearchRequest::__construct(SomeWork\P2PPathFinder\Domain\Order\OrderBook $orderBook, SomeWork\P2PPathFinder\Application\PathSearch\Config\PathSearchConfig $config, string $targetAsset)`

### orderBook
`PathSearchRequest::orderBook(): SomeWork\P2PPathFinder\Domain\Order\OrderBook`

### config
`PathSearchRequest::config(): SomeWork\P2PPathFinder\Application\PathSearch\Config\PathSearchConfig`

### targetAsset
`PathSearchRequest::targetAsset(): string`

### spendAmount
`PathSearchRequest::spendAmount(): SomeWork\P2PPathFinder\Domain\Money\Money`

### sourceAsset
`PathSearchRequest::sourceAsset(): string`

### minimumHops
`PathSearchRequest::minimumHops(): int`

### maximumHops
`PathSearchRequest::maximumHops(): int`

### spendConstraints
`PathSearchRequest::spendConstraints(): SomeWork\P2PPathFinder\Application\PathSearch\Model\SpendConstraints`

## SomeWork\P2PPathFinder\Application\PathSearch\Api\Response\SearchOutcome
Immutable response DTO describing the outcome of a path search.

Carries discovered {@see Path}
instances built from hop-centric DTOs ({@see \SomeWork\P2PPathFinder\Application\PathSearch\Result\PathHop}
/ {@see \SomeWork\P2PPathFinder\Application\PathSearch\Result\PathHopCollection})
alongside guard rail metrics.

### Public methods

### __construct
`SearchOutcome::__construct(SomeWork\P2PPathFinder\Application\PathSearch\Result\PathResultSet $paths, SomeWork\P2PPathFinder\Application\PathSearch\Result\SearchGuardReport $guardLimits)`

Create a new SearchOutcome containing discovered paths and their guard-rail metrics.

Parameter $paths: PathResultSet&lt;TPath&gt; — the collection of discovered Path instances
Parameter $guardLimits: SearchGuardReport — the guard-rail report describing limits and metrics observed during search

### fromResultSet
`SearchOutcome::fromResultSet(SomeWork\P2PPathFinder\Application\PathSearch\Result\PathResultSet $paths, SomeWork\P2PPathFinder\Application\PathSearch\Result\SearchGuardReport $guardLimits): self`

Create a SearchOutcome from an existing set of discovered paths and its guard report.




Parameter $paths: PathResultSet&lt;TOutcome&gt; — discovered Path instances to include in the outcome
Parameter $guardLimits: SearchGuardReport — guard metrics and limits produced during the search



Returns: self&lt;TOutcome&gt; a SearchOutcome containing the provided paths and guard report

### empty
`SearchOutcome::empty(SomeWork\P2PPathFinder\Application\PathSearch\Result\SearchGuardReport $guardLimits): self`

Create a SearchOutcome with no paths while retaining the provided guard report.

Parameter $guardLimits: SearchGuardReport — guard-rail metrics and limits to include in the outcome

Returns: self&lt;Path&gt; a SearchOutcome containing an empty PathResultSet and the given guard limits

### paths
`SearchOutcome::paths(): SomeWork\P2PPathFinder\Application\PathSearch\Result\PathResultSet`

Returns: PathResultSet&lt;TPath&gt;

### bestPath
`SearchOutcome::bestPath(): ?SomeWork\P2PPathFinder\Application\PathSearch\Result\Path`

Get the best (first) path from the result set.

Returns: TPath|null the first path from the result set, or `null` if none exist

### hasPaths
`SearchOutcome::hasPaths(): bool`

### guardLimits
`SearchOutcome::guardLimits(): SomeWork\P2PPathFinder\Application\PathSearch\Result\SearchGuardReport`

## SomeWork\P2PPathFinder\Application\PathSearch\Config\PathSearchConfig
Immutable configuration carrying constraints used by {@see PathSearchService}.

## Invariants

- **Hop constraints**: minimumHops >= 1, maximumHops >= minimumHops
- **Result limit**: resultLimit >= 1
- **Spend bounds computation**:
- minSpend = spendAmount × (1 - toleranceWindow.minimum)
- maxSpend = spendAmount × (1 + toleranceWindow.maximum)
- **Bounds ordering**: minSpend <= spendAmount <= maxSpend
- **Tolerance resolution**: pathFinderTolerance = override OR toleranceWindow.heuristicTolerance

### Public methods

### __construct
`PathSearchConfig::__construct(SomeWork\P2PPathFinder\Domain\Money\Money $spendAmount, SomeWork\P2PPathFinder\Domain\Tolerance\ToleranceWindow $toleranceWindow, int $minimumHops, int $maximumHops, int $resultLimit = 1, ?SomeWork\P2PPathFinder\Application\PathSearch\Config\SearchGuardConfig $searchGuards = null, ?string $pathFinderToleranceOverride = null, bool $throwOnGuardLimit = false)`

### builder
`PathSearchConfig::builder(): SomeWork\P2PPathFinder\Application\PathSearch\Config\PathSearchConfigBuilder`

Returns a fluent builder for constructing configuration instances.

### spendAmount
`PathSearchConfig::spendAmount(): SomeWork\P2PPathFinder\Domain\Money\Money`

Returns the target spend amount expressed in the source asset.

### toleranceWindow
`PathSearchConfig::toleranceWindow(): SomeWork\P2PPathFinder\Domain\Tolerance\ToleranceWindow`

Returns the tolerance window applied to the spend amount.

### minimumTolerance
`PathSearchConfig::minimumTolerance(): string`

Returns the lower relative tolerance bound expressed as a fraction.

Returns: numeric-string

### maximumTolerance
`PathSearchConfig::maximumTolerance(): string`

Returns the upper relative tolerance bound expressed as a fraction.

Returns: numeric-string

### minimumHops
`PathSearchConfig::minimumHops(): int`

Returns the minimum number of hops allowed in a resulting path.

### maximumHops
`PathSearchConfig::maximumHops(): int`

Returns the maximum number of hops allowed in a resulting path.

### resultLimit
`PathSearchConfig::resultLimit(): int`

Returns the maximum number of paths that should be returned by the search.

### pathFinderMaxExpansions
`PathSearchConfig::pathFinderMaxExpansions(): int`

Returns the maximum number of state expansions the path finder is allowed to perform.

### pathFinderMaxVisitedStates
`PathSearchConfig::pathFinderMaxVisitedStates(): int`

Returns the maximum number of unique state signatures tracked during search.

### pathFinderTimeBudgetMs
`PathSearchConfig::pathFinderTimeBudgetMs(): ?int`

### minimumSpendAmount
`PathSearchConfig::minimumSpendAmount(): SomeWork\P2PPathFinder\Domain\Money\Money`

Returns the minimum amount that can be spent after tolerance adjustments.

### maximumSpendAmount
`PathSearchConfig::maximumSpendAmount(): SomeWork\P2PPathFinder\Domain\Money\Money`

Returns the maximum amount that can be spent after tolerance adjustments.

### pathFinderTolerance
`PathSearchConfig::pathFinderTolerance(): string`

Returns the tolerance value used by the graph search heuristic.

Returns: numeric-string

### pathFinderToleranceSource
`PathSearchConfig::pathFinderToleranceSource(): string`

Returns the origin of the path finder tolerance value.

Returns: 'override'|'minimum'|'maximum'

### throwOnGuardLimit
`PathSearchConfig::throwOnGuardLimit(): bool`

## SomeWork\P2PPathFinder\Application\PathSearch\Config\PathSearchConfigBuilder
Fluent builder used to construct {@see PathSearchConfig} instances.

### Public methods

### withSpendAmount
`PathSearchConfigBuilder::withSpendAmount(SomeWork\P2PPathFinder\Domain\Money\Money $amount): self`

Sets the amount of the source asset that will be spent during path search.

### withToleranceBounds
`PathSearchConfigBuilder::withToleranceBounds(string $minimumTolerance, string $maximumTolerance): self`

Configures the acceptable relative deviation from the desired spend amount.

### withHopLimits
`PathSearchConfigBuilder::withHopLimits(int $minimumHops, int $maximumHops): self`

Configures the minimum and maximum allowed number of hops in a resulting path.

### withResultLimit
`PathSearchConfigBuilder::withResultLimit(int $limit): self`

Limits how many paths should be returned by the search service.

### withSearchGuards
`PathSearchConfigBuilder::withSearchGuards(int $maxVisitedStates, int $maxExpansions, ?int $timeBudgetMs = null): self`

Configures limits that guard search explosion in dense graphs.

Parameter $maxVisitedStates: int — Maximum unique states to track (affects memory: ~1KB per state)
Parameter $maxExpansions: int — Maximum edge expansions (affects computation time)
Parameter $timeBudgetMs: int|null — Optional wall-clock budget in milliseconds

### withSearchTimeBudget
`PathSearchConfigBuilder::withSearchTimeBudget(?int $timeBudgetMs): self`

Configures an optional wall-clock budget (in milliseconds) for the path finder search.

### withGuardLimitException
`PathSearchConfigBuilder::withGuardLimitException(bool $shouldThrow = true): self`

### build
`PathSearchConfigBuilder::build(): SomeWork\P2PPathFinder\Application\PathSearch\Config\PathSearchConfig`

Builds a validated {@see PathSearchConfig} instance.

## SomeWork\P2PPathFinder\Application\PathSearch\Config\SearchGuardConfig
Immutable guard limits used by the {@see \SomeWork\P2PPathFinder\Application\PathSearch\Service\PathSearchService} guard mechanism.

These limits control both computational cost and memory usage during path search.

### Public methods

### __construct
`SearchGuardConfig::__construct(int $maxVisitedStates = 250000, int $maxExpansions = 250000, ?int $timeBudgetMs = null)`

Parameter $maxVisitedStates: int — Maximum unique states to track in registry (affects memory: ~1KB per state, ~250MB at default limit)
Parameter $maxExpansions: int — Maximum edge expansions to perform (affects computation time and memory indirectly via state creation)
Parameter $timeBudgetMs: int|null — Optional wall-clock budget in milliseconds to halt search regardless of other limits

### defaults
`SearchGuardConfig::defaults(): self`

### withTimeBudget
`SearchGuardConfig::withTimeBudget(?int $timeBudgetMs): self`

### maxVisitedStates
`SearchGuardConfig::maxVisitedStates(): int`

### maxExpansions
`SearchGuardConfig::maxExpansions(): int`

### timeBudgetMs
`SearchGuardConfig::timeBudgetMs(): ?int`

## SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\CostHopsSignatureOrderingStrategy

### Public methods

### __construct
`CostHopsSignatureOrderingStrategy::__construct(int $costScale)`

### compare
`CostHopsSignatureOrderingStrategy::compare(SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathOrderKey $left, SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathOrderKey $right): int`

## SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathCost

### Public methods

### __construct
`PathCost::__construct(Brick\Math\BigDecimal|string $value)`

Creates a path cost from a numeric string or BigDecimal.

The value is normalized to 18 decimal places using HALF_UP rounding,
ensuring consistent precision for all cost calculations and comparisons.

Parameter $value: numeric-string|BigDecimal — The cost value to store

### value
`PathCost::value(): string`

Returns the cost as a canonical numeric string at 18 decimal places.

Returns: numeric-string The cost (e.g., "1.234567890123456789")

### decimal
`PathCost::decimal(): Brick\Math\BigDecimal`

Returns the underlying BigDecimal representation at normalized scale.

Returns: BigDecimal The cost as a BigDecimal at 18 decimal places

### equals
`PathCost::equals(self $other): bool`

Checks if this cost equals another cost at full precision.

Parameter $other: self — The cost to compare against

Returns: bool True if costs are equal at normalized scale

### compare
`PathCost::compare(self $other, int $scale = 18): int`

Compares this cost to another cost with optional scale control.

Both costs are rescaled to the specified comparison scale using HALF_UP
rounding before comparison. Passing a scale smaller than NORMALIZED_SCALE
effectively rounds both costs down to that precision, which may cause
costs that differ only in lower-order digits to compare as equal.

Parameter $other: self — The cost to compare against
Parameter $scale: int — The decimal scale for comparison (default: 18)

Returns: int -1 if this cost is less, 0 if equal, 1 if greater at the given scale

### __toString
`PathCost::__toString(): string`

## SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathOrderKey
psalm-type Payload = array<string, mixed>

phpstan-type Payload array<string, mixed>

### Public methods

### __construct
`PathOrderKey::__construct(SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathCost $cost, int $hops, SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\RouteSignature $routeSignature, int $insertionOrder, array $payload = [])`

Parameter $payload: Payload

### cost
`PathOrderKey::cost(): SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathCost`

### hops
`PathOrderKey::hops(): int`

### routeSignature
`PathOrderKey::routeSignature(): SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\RouteSignature`

### insertionOrder
`PathOrderKey::insertionOrder(): int`

### payload
`PathOrderKey::payload(): array`

Returns: Payload

## SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathOrderStrategy
Defines a strategy for ordering and prioritizing candidate paths during search.

Implementations of this interface determine how paths are ranked relative to each other,
which directly influences which paths appear first in search results. This is a key
extension point for customizing search behavior based on business requirements.

## Core Responsibilities

- **Prioritization**: Define the relative importance of path attributes (cost, hops, route).
- **Stable Sorting**: Ensure that paths with equal rank maintain consistent ordering.
- **Determinism**: Produce the same ordering for the same inputs across multiple executions.

## Contract Requirements

Implementations MUST adhere to the following contract:

1. **Comparison Semantics**: The `compare()` method must return:
- **Negative integer** if `$left` should rank BEFORE `$right` (lower rank = higher priority)
- **Zero** if `$left` and `$right` have equal rank
- **Positive integer** if `$left` should rank AFTER `$right`

2. **Transitivity**: If A < B and B < C, then A < C must hold.

3. **Stability**: To ensure stable sorting, always fall back to `insertionOrder()` as the
final tie-breaker when all other attributes are equal:

```php
if ($result === 0) {
return $left->insertionOrder() <=> $right->insertionOrder();
}
```

4. **Determinism**: Given the same `PathOrderKey` objects, `compare()` must always return
the same result. Avoid non-deterministic operations like:
- Random number generation
- System time or timestamps (unless part of the key data)
- Unordered data structures (like raw hash sets)

5. **Consistency**: The ordering must be consistent with the mathematical properties of
comparison. Specifically:
- `compare(A, B)` must equal `-compare(B, A)` (antisymmetry)
- If `compare(A, B) == 0`, then `compare(A, C)` must equal `compare(B, C)` for any C

## Implementation Guidelines

- **Performance**: Keep `compare()` fast; it may be called thousands of times during a search.
- **Stateless**: Avoid mutable state within the strategy; use constructor parameters for configuration.
- **Clear Priority**: Document the ordering criteria clearly in your implementation's PHPDoc.
- **Decimal Precision**: When comparing costs, consider using `PathCost::compare()` with
an appropriate scale to avoid floating-point issues.

## Common Ordering Strategies

- **Cost-first** (default): Minimize total path cost, then hops, then route signature.
- **Hops-first**: Minimize number of hops (route complexity), then cost.
- **Hybrid**: Balance cost and hops using weighted scoring.
- **Route-aware**: Prefer certain currencies or exchanges in the path.

## Usage with PathSearchService

Pass your custom strategy to the `PathSearchService` constructor:

```php
use SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\MinimizeHopsStrategy;
use SomeWork\P2PPathFinder\Application\PathSearch\Service\GraphBuilder;
use SomeWork\P2PPathFinder\Application\PathSearch\Service\PathSearchService;

$graphBuilder = new GraphBuilder();
$customStrategy = new MinimizeHopsStrategy(costScale: 6);
$service = new PathSearchService($graphBuilder, $customStrategy);
```

### Public methods

### compare
`PathOrderStrategy::compare(SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathOrderKey $left, SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathOrderKey $right): int`

Compares two path order keys to determine their relative priority.

Implementations must return:
- A negative integer if `$left` should be prioritized over `$right`
- Zero if both paths have equal priority
- A positive integer if `$right` should be prioritized over `$left`

IMPORTANT**: Always use `insertionOrder()` as the final tie-breaker to ensure
stable sorting behavior:

```php
// After all your comparison logic...
if ($result === 0) {
return $left->insertionOrder() <=> $right->insertionOrder();
}
```


Parameter $left: PathOrderKey — The first path to compare
Parameter $right: PathOrderKey — The second path to compare

Returns: int Negative if $left &lt; $right, zero if equal, positive if $left &gt; $right

## SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\RouteSignature

### Public methods

### fromNodes
`RouteSignature::fromNodes(array $nodes): self`

Parameter $nodes: list&lt;string&gt;

### nodes
`RouteSignature::nodes(): array`

Returns: list&lt;string&gt;

### value
`RouteSignature::value(): string`

### equals
`RouteSignature::equals(self $other): bool`

### compare
`RouteSignature::compare(self $other): int`

### __toString
`RouteSignature::__toString(): string`

## SomeWork\P2PPathFinder\Application\PathSearch\Model\SpendConstraints
Represents the spend boundaries derived from tolerance window configuration.

This value object encapsulates the minimum, maximum, and desired spend amounts
that constrain path finding. It is exposed through PathSearchRequest::spendConstraints()
to provide read-only access to the derived spend boundaries.

Consumers typically don't need to interact with this directly as the path finding
happens automatically based on the PathSearchConfig. It's provided for transparency
into how the tolerance window translates to actual spend constraints.

### Public methods

### from
`SpendConstraints::from(SomeWork\P2PPathFinder\Domain\Money\Money $min, SomeWork\P2PPathFinder\Domain\Money\Money $max, ?SomeWork\P2PPathFinder\Domain\Money\Money $desired = null): self`

### fromScalars
`SpendConstraints::fromScalars(string $currency, string $min, string $max, ?string $desired = null): self`

Parameter $min: numeric-string
Parameter $max: numeric-string
Parameter $desired: numeric-string|null

### min
`SpendConstraints::min(): SomeWork\P2PPathFinder\Domain\Money\Money`

### max
`SpendConstraints::max(): SomeWork\P2PPathFinder\Domain\Money\Money`

### bounds
`SpendConstraints::bounds(): array`

Returns: array{min: Money, max: Money}

### desired
`SpendConstraints::desired(): ?SomeWork\P2PPathFinder\Domain\Money\Money`

## SomeWork\P2PPathFinder\Application\PathSearch\Result\Path
Aggregated representation of a discovered conversion path derived from hops.

Encapsulates a contiguous {@see PathHopCollection} so callers can inspect
individual {@see PathHop} steps alongside aggregate amounts, fees, and
residual tolerance derived from the hop sequence.

### Public methods

### __construct
`Path::__construct(SomeWork\P2PPathFinder\Application\PathSearch\Result\PathHopCollection $hops, SomeWork\P2PPathFinder\Domain\Tolerance\DecimalTolerance $residualTolerance)`

### hops
`Path::hops(): SomeWork\P2PPathFinder\Application\PathSearch\Result\PathHopCollection`

### hopsAsArray
`Path::hopsAsArray(): array`

Returns: list&lt;PathHop&gt;

### totalSpent
`Path::totalSpent(): SomeWork\P2PPathFinder\Domain\Money\Money`

### totalReceived
`Path::totalReceived(): SomeWork\P2PPathFinder\Domain\Money\Money`

### feeBreakdown
`Path::feeBreakdown(): SomeWork\P2PPathFinder\Domain\Money\MoneyMap`

### feeBreakdownAsArray
`Path::feeBreakdownAsArray(): array`

Returns: array&lt;string, Money&gt;

### residualTolerance
`Path::residualTolerance(): SomeWork\P2PPathFinder\Domain\Tolerance\DecimalTolerance`

Returns the remaining tolerance after accounting for the chosen path.

### residualTolerancePercentage
`Path::residualTolerancePercentage(int $scale = 2): string`

### toArray
`Path::toArray(): array`

Returns: array{
totalSpent: Money,
totalReceived: Money,
residualTolerance: DecimalTolerance,
feeBreakdown: MoneyMap,
hops: PathHopCollection,
}

## SomeWork\P2PPathFinder\Application\PathSearch\Result\PathHop
Describes a single conversion hop in a path finder result.

Each hop preserves the originating {@see Order}, normalized assets, hop-level
fees, and the spent/received amounts so you can trace fills without
re-computing conversions when traversing a {@see Path}.

### Public methods

### __construct
`PathHop::__construct(string $fromAsset, string $toAsset, SomeWork\P2PPathFinder\Domain\Money\Money $spent, SomeWork\P2PPathFinder\Domain\Money\Money $received, SomeWork\P2PPathFinder\Domain\Order\Order $order, ?SomeWork\P2PPathFinder\Domain\Money\MoneyMap $fees = null)`

### from
`PathHop::from(): string`

Returns the asset symbol of the hop's source.

### to
`PathHop::to(): string`

Returns the asset symbol of the hop's destination.

### spent
`PathHop::spent(): SomeWork\P2PPathFinder\Domain\Money\Money`

Returns the amount of source asset spent in this hop.

### received
`PathHop::received(): SomeWork\P2PPathFinder\Domain\Money\Money`

Returns the amount of destination asset received in this hop.

### order
`PathHop::order(): SomeWork\P2PPathFinder\Domain\Order\Order`

Returns the order associated with this hop.

### fees
`PathHop::fees(): SomeWork\P2PPathFinder\Domain\Money\MoneyMap`

### feesAsArray
`PathHop::feesAsArray(): array`

Returns: array&lt;string, Money&gt;

### toArray
`PathHop::toArray(): array`

Returns: array{
from: string,
to: string,
spent: Money,
received: Money,
fees: MoneyMap,
order: Order,
}

## SomeWork\P2PPathFinder\Application\PathSearch\Result\PathHopCollection
Immutable ordered collection of {@see PathHop} instances.

Enforces contiguity and uniqueness so routes can be consumed safely by
{@see Path} aggregations and downstream formatters.

### Public methods

### empty
`PathHopCollection::empty(): self`

### fromList
`PathHopCollection::fromList(array $hops): self`

Parameter $hops: array&lt;array-key, PathHop&gt;

### count
`PathHopCollection::count(): int`

### getIterator
`PathHopCollection::getIterator(): Traversable`

Returns: Traversable&lt;int, PathHop&gt;

### all
`PathHopCollection::all(): array`

Returns: list&lt;PathHop&gt;

### toArray
`PathHopCollection::toArray(): array`

Returns: list&lt;PathHop&gt;

### isEmpty
`PathHopCollection::isEmpty(): bool`

### at
`PathHopCollection::at(int $index): SomeWork\P2PPathFinder\Application\PathSearch\Result\PathHop`

### first
`PathHopCollection::first(): ?SomeWork\P2PPathFinder\Application\PathSearch\Result\PathHop`

### last
`PathHopCollection::last(): ?SomeWork\P2PPathFinder\Application\PathSearch\Result\PathHop`

## SomeWork\P2PPathFinder\Application\PathSearch\Result\PathResultSet
Immutable collection of ordered path results.

### Public methods

### empty
`PathResultSet::empty(): self`

Returns: PathResultSet&lt;TPath&gt;

### fromPaths
`PathResultSet::fromPaths(SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathOrderStrategy $orderingStrategy, iterable $paths, callable $orderKeyResolver): self`

Parameter $paths: iterable&lt;TIn&gt;
Parameter $orderKeyResolver: callable(TIn, int): PathOrderKey

Returns: PathResultSet&lt;TIn&gt;

### getIterator
`PathResultSet::getIterator(): Traversable`

Returns: Traversable&lt;int, TPath&gt;

### count
`PathResultSet::count(): int`

### isEmpty
`PathResultSet::isEmpty(): bool`

### toArray
`PathResultSet::toArray(): array`

Returns: list&lt;TPath&gt;

### slice
`PathResultSet::slice(int $offset, ?int $length = null): self`

Returns: PathResultSet&lt;TPath&gt;

### first
`PathResultSet::first(): mixed`

Returns: TPath|null

## SomeWork\P2PPathFinder\Application\PathSearch\Result\SearchGuardReport
Immutable snapshot describing how the search interacted with its guard rails.

### Public methods

### __construct
`SearchGuardReport::__construct(bool $expansionsReached, bool $visitedStatesReached, bool $timeBudgetReached, int $expansions, int $visitedStates, float $elapsedMilliseconds, int $expansionLimit, int $visitedStateLimit, ?int $timeBudgetLimit)`

### fromMetrics
`SearchGuardReport::fromMetrics(int $expansions, int $visitedStates, float $elapsedMilliseconds, int $expansionLimit, int $visitedStateLimit, ?int $timeBudgetLimit, bool $expansionLimitReached = false, bool $visitedStatesReached = false, bool $timeBudgetReached = false): self`

### idle
`SearchGuardReport::idle(int $maxVisitedStates, int $maxExpansions, ?int $timeBudgetMs = null): self`

### none
`SearchGuardReport::none(): self`

### expansionsReached
`SearchGuardReport::expansionsReached(): bool`

### visitedStatesReached
`SearchGuardReport::visitedStatesReached(): bool`

### timeBudgetReached
`SearchGuardReport::timeBudgetReached(): bool`

### anyLimitReached
`SearchGuardReport::anyLimitReached(): bool`

### expansions
`SearchGuardReport::expansions(): int`

### visitedStates
`SearchGuardReport::visitedStates(): int`

### elapsedMilliseconds
`SearchGuardReport::elapsedMilliseconds(): float`

### expansionLimit
`SearchGuardReport::expansionLimit(): int`

### visitedStateLimit
`SearchGuardReport::visitedStateLimit(): int`

### timeBudgetLimit
`SearchGuardReport::timeBudgetLimit(): ?int`

## SomeWork\P2PPathFinder\Application\PathSearch\Service\GraphBuilder
Converts a collection of domain orders into a weighted directed graph representation.

### Public methods

### __construct
`GraphBuilder::__construct()`

### build
`GraphBuilder::build(iterable $orders): SomeWork\P2PPathFinder\Application\PathSearch\Model\Graph\Graph`

Parameter $orders: iterable&lt;Order&gt;

## SomeWork\P2PPathFinder\Application\PathSearch\Service\PathSearchService
High level facade orchestrating order filtering, graph building and path search.



psalm-type CandidateCallback = callable(CandidatePath):bool

### Public methods

### __construct
`PathSearchService::__construct(SomeWork\P2PPathFinder\Application\PathSearch\Service\GraphBuilder $graphBuilder, ?SomeWork\P2PPathFinder\Application\PathSearch\Engine\Ordering\PathOrderStrategy $orderingStrategy = null)`

### findBestPaths
`PathSearchService::findBestPaths(SomeWork\P2PPathFinder\Application\PathSearch\Api\Request\PathSearchRequest $request): SomeWork\P2PPathFinder\Application\PathSearch\Api\Response\SearchOutcome`

Searches for the best conversion paths from the configured spend asset to the target asset.

Guard limit breaches are reported through the returned {@see SearchOutcome::guardLimits()}
metadata. Inspect the {@see SearchGuardReport} via helpers like
{@see SearchGuardReport::anyLimitReached()} to determine whether the search exhausted its
configured protections.



Returns: SearchOutcome&lt;Path&gt;




// Create request and execute search
$request = new PathSearchRequest($orderBook, $config, 'BTC');
$outcome = $service->findBestPaths($request);

// Process results
$bestPath = $outcome->bestPath();
if (null !== $bestPath) {
echo "Best path spends {$bestPath->totalSpent()->amount()} {$bestPath->totalSpent()->currency()}\n";
echo "Best path receives {$bestPath->totalReceived()->amount()} {$bestPath->totalReceived()->currency()}\n";

foreach ($bestPath->hops() as $index => $hop) {
$order = $hop->order();
$pair = $order->assetPair();

printf(
"Hop %d (%s order %s/%s): spend %s %s to receive %s %s\n",
$index + 1,
$order->side()->value,
$pair->base(),
$pair->quote(),
$hop->spent()->amount(),
$hop->spent()->currency(),
$hop->received()->amount(),
$hop->received()->currency(),
);
}
}

// Check guard limits
if ($outcome->guardLimits()->anyLimitReached()) {
echo "Search was limited by guard rails\n";
}
```

## SomeWork\P2PPathFinder\Application\PathSearch\Support\PathResultFormatter
Provides machine and human friendly representations of {@see Path} instances.

### Public methods

### formatHuman
`PathResultFormatter::formatHuman(SomeWork\P2PPathFinder\Application\PathSearch\Result\Path $result): string`

Produces a multi-line human readable summary of the conversion path.

### formatHumanCollection
`PathResultFormatter::formatHumanCollection(SomeWork\P2PPathFinder\Application\PathSearch\Result\PathResultSet|array $results): string`

Parameter $results: PathResultSet&lt;Path&gt;|list&lt;Path&gt;

## SomeWork\P2PPathFinder\Domain\Money\AssetPair
Value object describing a directed asset pair (base -> quote).

## Invariants

- **Distinct assets**: Base and quote must be distinct (after normalization)
- **Valid currencies**: Both must match /^[A-Z]{3,12}$/

### Public methods

### fromString
`AssetPair::fromString(string $base, string $quote): self`

Creates an asset pair ensuring the provided currencies are distinct and valid.

### base
`AssetPair::base(): string`

Returns the normalized base asset symbol.

### quote
`AssetPair::quote(): string`

Returns the normalized quote asset symbol.

## SomeWork\P2PPathFinder\Domain\Money\ExchangeRate
Value object encapsulating an exchange rate between two assets.

## Invariants

- **Distinct currencies**: Base and quote currencies must be distinct (case-insensitive)
- **Positive rate**: Exchange rate must be strictly positive (> 0)
- **Valid currencies**: Both currencies must match /^[A-Z]{3,12}$/
- **Scale bounds**: Scale must be 0 <= scale <= 50
- **Rate inversion**: invert() returns rate with swapped currencies and inverted value

### Public methods

### fromString
`ExchangeRate::fromString(string $baseCurrency, string $quoteCurrency, string $rate, int $scale = 8): self`

Builds an exchange rate for the provided currency pair and numeric rate.

Parameter $baseCurrency: non-empty-string
Parameter $quoteCurrency: non-empty-string
Parameter $rate: numeric-string

### convert
`ExchangeRate::convert(SomeWork\P2PPathFinder\Domain\Money\Money $money, ?int $scale = null): SomeWork\P2PPathFinder\Domain\Money\Money`

Converts a base currency amount into its quote currency representation.

### invert
`ExchangeRate::invert(): self`

Returns the inverted exchange rate (quote becomes base and vice versa).

### baseCurrency
`ExchangeRate::baseCurrency(): string`

Returns: non-empty-string

### quoteCurrency
`ExchangeRate::quoteCurrency(): string`

Returns: non-empty-string

### rate
`ExchangeRate::rate(): string`

Returns: numeric-string

### scale
`ExchangeRate::scale(): int`

Returns the scale used by the rate for arbitrary precision operations.

### decimal
`ExchangeRate::decimal(): Brick\Math\BigDecimal`

Returns the BigDecimal representation of the rate.

## SomeWork\P2PPathFinder\Domain\Money\Money
Immutable representation of a monetary amount backed by arbitrary precision arithmetic.

Money instances always carry their currency code, normalized amount representation and
the scale used when interacting with arbitrary precision operations. Instances are created
through named constructors to guarantee validation and normalization of their internal state.

## Invariants

- **Non-negative amounts**: Money amounts must be >= 0. Negative amounts have no semantic
meaning in the path-finding domain (orders, spends, receives, fees are all naturally
non-negative). Construction with negative amounts throws InvalidInput.
- **Valid currency**: Currency code must be 3-12 uppercase letters matching /^[A-Z]{3,12}$/
- **Scale bounds**: Scale must be 0 <= scale <= 50 to prevent memory/performance issues
- **Precision preservation**: Amounts are stored as BigDecimal and normalized to the
specified scale using HALF_UP rounding

## Scale Derivation Rules

Arithmetic operations follow deterministic scale derivation rules to ensure predictable
precision handling:

- **Addition/Subtraction**: Result scale = max(left.scale, right.scale) unless explicitly
overridden. This ensures no precision loss from either operand.
- **Multiplication/Division**: Result scale = left.scale (the Money instance's scale) unless
explicitly overridden. Scalar operands do not influence the result scale.
- **Explicit Override**: All arithmetic operations accept an optional scale parameter that
takes precedence over default derivation rules.
- **Comparison**: Uses max(left.scale, right.scale, explicitScale) to ensure accurate
comparison at the highest precision available.

### Public methods

### fromString
`Money::fromString(string $currency, string $amount, int $scale = 2): self`

Creates a new money instance from raw string components.

Parameter $currency: string — ISO-like currency symbol comprised of 3-12 alphabetic characters
Parameter $amount: numeric-string — numeric string convertible to an arbitrary precision decimal
Parameter $scale: int — number of decimal digits to retain after normalization



// Cryptocurrencies (higher precision)
$btc = Money::fromString('BTC', '0.00420000', 8);
$eth = Money::fromString('ETH', '1.500000000000000000', 18);
```

### zero
`Money::zero(string $currency, int $scale = 2): self`

Creates a zero-value amount for the provided currency and scale.

### withScale
`Money::withScale(int $scale): self`

Returns a copy of the money instance rounded to the provided scale.

### currency
`Money::currency(): string`

Retrieves the ISO-like currency code of the amount.

### amount
`Money::amount(): string`

Returns the normalized numeric string representation of the amount.


Returns: numeric-string

### scale
`Money::scale(): int`

Returns the scale (number of fractional digits) used for the amount.

### decimal
`Money::decimal(): Brick\Math\BigDecimal`

Returns the BigDecimal representation of the amount.

### add
`Money::add(self $other, ?int $scale = null): self`

Adds another money value using a common scale.

Parameter $other: self — money value expressed in the same currency
Parameter $scale: int|null — optional explicit scale override

### subtract
`Money::subtract(self $other, ?int $scale = null): self`

Subtracts another money value using a common scale.

Parameter $other: self — money value expressed in the same currency
Parameter $scale: int|null — optional explicit scale override

### multiply
`Money::multiply(string $multiplier, ?int $scale = null): self`

Multiplies the amount by a scalar numeric multiplier.

Parameter $multiplier: numeric-string — numeric multiplier convertible to an arbitrary precision decimal
Parameter $scale: int|null — optional explicit scale override

### divide
`Money::divide(string $divisor, ?int $scale = null): self`

Divides the amount by a scalar numeric divisor.

Parameter $divisor: numeric-string — numeric divisor convertible to an arbitrary precision decimal
Parameter $scale: int|null — optional explicit scale override

### compare
`Money::compare(self $other, ?int $scale = null): int`

Compares two money values using the provided or derived scale.

Parameter $other: self — money value expressed in the same currency
Parameter $scale: int|null — optional explicit scale override


Returns: int -1, 0 or 1 depending on the comparison result

### equals
`Money::equals(self $other): bool`

Determines whether two money values are equal.

### greaterThan
`Money::greaterThan(self $other): bool`

Checks if the current amount is greater than the provided amount.

### lessThan
`Money::lessThan(self $other): bool`

Checks if the current amount is lower than the provided amount.

### isZero
`Money::isZero(): bool`

Indicates whether the amount equals zero at the stored scale.

## SomeWork\P2PPathFinder\Domain\Money\MoneyMap
Immutable map keyed by currency codes with {@see Money} entries.

### Public methods

### empty
`MoneyMap::empty(): self`

### fromList
`MoneyMap::fromList(iterable $entries, bool $skipZeroValues = false): self`

Parameter $entries: iterable&lt;Money&gt;

### fromAssociative
`MoneyMap::fromAssociative(iterable $entries, bool $skipZeroValues = false): self`

Parameter $entries: iterable&lt;mixed, Money&gt;

### isEmpty
`MoneyMap::isEmpty(): bool`

### count
`MoneyMap::count(): int`

### toArray
`MoneyMap::toArray(): array`

Returns: array&lt;string, Money&gt;

### getIterator
`MoneyMap::getIterator(): Traversable`

Returns: Traversable&lt;string, Money&gt;

### has
`MoneyMap::has(string $currency): bool`

### get
`MoneyMap::get(string $currency): ?SomeWork\P2PPathFinder\Domain\Money\Money`

### with
`MoneyMap::with(SomeWork\P2PPathFinder\Domain\Money\Money $money, bool $skipZeroValue = false): self`

### merge
`MoneyMap::merge(self $other): self`

## SomeWork\P2PPathFinder\Domain\Order\Fee\FeeBreakdown
Immutable value object describing the fee components for an order fill.

## Invariants

- **Optional fees**: Both baseFee and quoteFee are nullable (null = no fee)
- **Zero equivalence**: null and zero Money are treated equivalently
- **Merge behavior**: merge() sums fees component-wise

### Public methods

### none
`FeeBreakdown::none(): self`

### forBase
`FeeBreakdown::forBase(SomeWork\P2PPathFinder\Domain\Money\Money $baseFee): self`

### forQuote
`FeeBreakdown::forQuote(SomeWork\P2PPathFinder\Domain\Money\Money $quoteFee): self`

### of
`FeeBreakdown::of(?SomeWork\P2PPathFinder\Domain\Money\Money $baseFee, ?SomeWork\P2PPathFinder\Domain\Money\Money $quoteFee): self`

### baseFee
`FeeBreakdown::baseFee(): ?SomeWork\P2PPathFinder\Domain\Money\Money`

### quoteFee
`FeeBreakdown::quoteFee(): ?SomeWork\P2PPathFinder\Domain\Money\Money`

### hasBaseFee
`FeeBreakdown::hasBaseFee(): bool`

### hasQuoteFee
`FeeBreakdown::hasQuoteFee(): bool`

### isZero
`FeeBreakdown::isZero(): bool`

### merge
`FeeBreakdown::merge(self $other): self`

## SomeWork\P2PPathFinder\Domain\Order\Fee\FeePolicy
Defines a strategy for calculating fees applied to order fills.

Implementations of this interface allow consumers to define custom fee calculation logic
that is attached to `Order` instances. Fees are computed during path finding as the
algorithm evaluates how much of an order can be filled given spend constraints.

## Core Responsibilities

- **Fee Calculation**: Compute fee amounts based on order side and fill amounts
- **Currency Specification**: Return fees in the appropriate currency (base or quote)
- **Deterministic Identification**: Provide a unique fingerprint for the policy configuration

## When Fees Are Applied

Fees are calculated during the path finding process when:
1. The algorithm determines how much of an order can be filled
2. A candidate path is being evaluated for feasibility
3. The final path cost is being computed

The `calculate()` method is called with:
- The order's side (BUY or SELL)
- The base asset amount being traded
- The quote asset amount being traded

## Currency Constraints

Fees MUST be denominated in a currency that matches the order's trading pair:

- **Base Fees**: Must be in the same currency as `$baseAmount` (the order's base asset)
- **Quote Fees**: Must be in the same currency as `$quoteAmount` (the order's quote asset)
- **Both**: You can return fees in both currencies if needed

CRITICAL**: The currency of returned fees MUST match the corresponding Money object's
currency, or path finding calculations will fail. The system does NOT perform automatic
currency conversion for fees.

### Currency Examples:

For an order with pair USD/EUR:
- Base asset is USD → base fees must be in USD
- Quote asset is EUR → quote fees must be in EUR
- You can return fees in USD, EUR, or both, but NOT in any other currency

## Calculation Order

The path finding algorithm calls `calculate()` in this sequence:

1. **Order Evaluation**: For each order being considered, calculate fees based on
the proposed fill amounts
2. **Cost Accumulation**: Fees are added to the path's total cost
3. **Feasibility Check**: The system verifies the path (including fees) fits within
spend constraints and tolerance bounds

Fees affect:
- **Total Cost**: Higher fees increase path cost (used for ordering)
- **Output Amount**: Fees reduce the net amount received at each hop
- **Feasibility**: Large fees may make otherwise viable paths infeasible

## Implementation Guidelines

- **Stateless**: Avoid mutable state; use constructor parameters for configuration
- **Fast Computation**: Keep `calculate()` performant; it's called frequently during search
- **Precise Arithmetic**: Use `Money` and BigDecimal for all calculations to avoid precision loss
- **Currency Safety**: Always verify currency matches before creating fee Money objects
- **Non-negative**: Fees should be zero or positive (negative fees are not supported)
- **Deterministic**: Same inputs must always produce same outputs

## Common Fee Models

- **Percentage Fee**: Fee is a percentage of the traded amount (e.g., 0.5%)
- **Fixed Fee**: Flat fee per transaction (e.g., $2.50 per order)
- **Tiered Fee**: Fee rate depends on trade volume (e.g., 0.5% for <$1000, 0.3% for ≥$1000)
- **Maker/Taker**: Different fees based on order side (BUY vs SELL)
- **Combined**: Mix of percentage + fixed (e.g., 0.5% + $1.00)

## Fingerprint Requirements

The `fingerprint()` method MUST return a globally unique identifier that deterministically
represents the policy configuration. The fingerprint is used for stable ordering and
comparison of fee policies across the system.

1. **Uniqueness:** Different policy configurations MUST produce different fingerprints
2. **Determinism:** Same policy configuration MUST always produce the same fingerprint
3. **Non-empty:** Fingerprint MUST be a non-empty string
4. **Reasonable length:** Recommended ≤255 characters for practicality

### Recommended Fingerprint Format

Use colon-separated components: `"PolicyType:param1:param2:..."`

Examples:
- `"base-percentage:0.005:6"` (0.5% base fee at scale 6)
- `"quote-fixed:2.50:USD:2"` ($2.50 fixed quote fee in USD)
- `"tiered:0.005:1000:0.003:2"` (0.5% under $1000, 0.3% above)
- `"maker-taker:0.002:0.003:6"` (0.2% maker, 0.3% taker)

The recommended format ensures uniqueness by including:
- Policy type identifier (distinguishes different implementations)
- All configuration parameters that affect fee calculation
- Scale or precision information when relevant
- Currency information for fixed fees

## Usage with Orders

Attach a fee policy to an order at construction:

```php
$feePolicy = new PercentageFeePolicy(rate: '0.005', scale: 6);
$order = new Order($side, $pair, $bounds, $rate, $feePolicy);
```

Orders without a fee policy (null) are treated as fee-free.

### Public methods

### calculate
`FeePolicy::calculate(SomeWork\P2PPathFinder\Domain\Order\OrderSide $side, SomeWork\P2PPathFinder\Domain\Money\Money $baseAmount, SomeWork\P2PPathFinder\Domain\Money\Money $quoteAmount): SomeWork\P2PPathFinder\Domain\Order\Fee\FeeBreakdown`

Calculates the fee components to apply for the provided order side and amounts.

This method is called during path finding to determine fees for a specific order fill.
It receives the order's side and the proposed fill amounts for both base and quote assets.

Currency Constraints**: Returned fees MUST match the currency of the corresponding
Money parameter:
- Base fees must be in `$baseAmount->currency()`
- Quote fees must be in `$quoteAmount->currency()`

Return Value**: Use `FeeBreakdown` factory methods:
- `FeeBreakdown::none()` - No fees
- `FeeBreakdown::forBase($baseFee)` - Fee in base currency only
- `FeeBreakdown::forQuote($quoteFee)` - Fee in quote currency only
- `FeeBreakdown::of($baseFee, $quoteFee)` - Fees in both currencies

Performance**: This method may be called thousands of times during a search.
Keep computation fast and avoid expensive operations.

Parameter $side: OrderSide — The order side (BUY or SELL)
Parameter $baseAmount: Money — The amount being traded in the base asset
Parameter $quoteAmount: Money — The amount being traded in the quote asset

Returns: FeeBreakdown The calculated fee breakdown


public function calculate(OrderSide $side, Money $base, Money $quote): FeeBreakdown
{
// Calculate 0.5% fee on quote amount
$fee = $quote->multiply($this->rate, $quote->scale());
return FeeBreakdown::forQuote($fee);
}

public function fingerprint(): string
{
return "quote-percentage:{$this->rate}";
}
}

// Example: Tiered fee policy
class TieredFeePolicy implements FeePolicy
{
public function calculate(OrderSide $side, Money $base, Money $quote): FeeBreakdown
{
// 0.5% for < $1000, 0.25% for >= $1000
$rate = $quote->compareTo(Money::fromString('USD', '1000', 2)) >= 0
? '0.0025'  // 0.25%
: '0.005';  // 0.5%

$fee = $quote->multiply($rate, $quote->scale());
return FeeBreakdown::forQuote($fee);
}

public function fingerprint(): string
{
return 'tiered:0.005:1000:0.0025';
}
}
```

### fingerprint
`FeePolicy::fingerprint(): string`

Provides a stable identifier describing the policy configuration for deterministic ordering.

The fingerprint must be globally unique across all policy instances. Two policies with
different configurations (even of the same type) must return different fingerprints.


Returns: non-empty-string A unique identifier for this policy configuration

## SomeWork\P2PPathFinder\Domain\Order\Fee\FeePolicyHelper
Helper utilities for validating and working with FeePolicy implementations.

### Public methods

### validateFingerprint
`FeePolicyHelper::validateFingerprint(string $fingerprint): void`

Validates that a fingerprint meets the requirements specified in the FeePolicy contract.

Parameter $fingerprint: string — The fingerprint to validate

### fingerprintsEqual
`FeePolicyHelper::fingerprintsEqual(string $fingerprint1, string $fingerprint2): bool`

Checks if two fingerprints are identical.

Parameter $fingerprint1: string — First fingerprint
Parameter $fingerprint2: string — Second fingerprint

Returns: bool True if fingerprints are identical

### validateUniqueness
`FeePolicyHelper::validateUniqueness(array $fingerprints): void`

Validates that all provided fingerprints are unique.

Parameter $fingerprints: list&lt;string&gt; — Array of fingerprints to check

## SomeWork\P2PPathFinder\Domain\Order\Filter\OrderFilterInterface
Strategy interface for filtering orders before graph construction and path search.

Implementations determine whether specific orders should participate in path finding
by examining order properties (asset pairs, amounts, fees, etc.) and returning true
if the order passes the filter criteria.

## Usage

Filters are applied via OrderBook::filter() or by pre-filtering orders before
constructing an OrderBook. Multiple filters can be chained together.

## Performance Contract

- Filter evaluation MUST be O(1) per order (constant time)
- Avoid expensive operations like database queries or network calls
- Keep filter logic simple and focused on a single concern
- Cache computed values in constructor if needed

## Immutability Contract

- Filters MUST NOT modify the order being evaluated
- Filter state MUST be immutable after construction
- Filter evaluation MUST be side-effect free (pure function)
- Thread-safe by design (stateless evaluation)

## Best Practices

1. **Single Responsibility**: Each filter should check one criterion
2. **Composition**: Combine multiple simple filters rather than one complex filter
3. **Early Return**: Return false as soon as a condition fails
4. **Scale Handling**: Normalize scales when comparing Money values
5. **Currency Matching**: Always verify currency compatibility before comparisons

## Example Implementation

```php
final class MaxSpreadFilter implements OrderFilterInterface
{
public function __construct(private readonly string $maxSpread) {}

public function accepts(Order $order): bool
{
$rate = $order->effectiveRate();
$spread = $this->calculateSpread($rate);
return bccomp($spread, $this->maxSpread, 8) <= 0;
}
}
```

### Public methods

### accepts
`OrderFilterInterface::accepts(SomeWork\P2PPathFinder\Domain\Order\Order $order): bool`

Determines whether the provided order satisfies the filter conditions.

This method MUST be side-effect free and MUST NOT modify the order.
It should execute in constant time O(1) relative to the order book size.


Parameter $order: Order — The order to evaluate (MUST NOT be modified)

Returns: bool True if the order passes the filter and should be included,
false if the order should be excluded from path finding

## SomeWork\P2PPathFinder\Domain\Order\Order
Domain entity describing an order that can be traversed within a path search.

## Invariants

- **Currency consistency**: All components must align with AssetPair
- Bounds must be in base currency
- Effective rate base/quote must match asset pair base/quote
- Base fees (if present) must be in base currency
- Quote fees (if present) must be in quote currency
- **Partial fill validation**: Fill amounts must be within bounds and in base currency
- **Quote calculation**: calculateQuoteAmount = effectiveRate.convert(baseAmount)
- **Effective quote**: calculateEffectiveQuoteAmount = quoteAmount - quoteFee (if present)
- **Gross spend**: calculateGrossBaseSpend = baseAmount + baseFee (if present)

### Public methods

### __construct
`Order::__construct(SomeWork\P2PPathFinder\Domain\Order\OrderSide $side, SomeWork\P2PPathFinder\Domain\Money\AssetPair $assetPair, SomeWork\P2PPathFinder\Domain\Order\OrderBounds $bounds, SomeWork\P2PPathFinder\Domain\Money\ExchangeRate $effectiveRate, ?SomeWork\P2PPathFinder\Domain\Order\Fee\FeePolicy $feePolicy = null)`

### side
`Order::side(): SomeWork\P2PPathFinder\Domain\Order\OrderSide`

Returns whether the order is a buy or sell side order.

### assetPair
`Order::assetPair(): SomeWork\P2PPathFinder\Domain\Money\AssetPair`

Returns the asset pair quoted by the order.

### bounds
`Order::bounds(): SomeWork\P2PPathFinder\Domain\Order\OrderBounds`

Returns the admissible fill bounds for the order's base asset.

### effectiveRate
`Order::effectiveRate(): SomeWork\P2PPathFinder\Domain\Money\ExchangeRate`

Returns the effective exchange rate applied when filling the order.

### feePolicy
`Order::feePolicy(): ?SomeWork\P2PPathFinder\Domain\Order\Fee\FeePolicy`

Returns the fee policy, if any, associated with the order.

### validatePartialFill
`Order::validatePartialFill(SomeWork\P2PPathFinder\Domain\Money\Money $baseAmount): void`

Validates that the provided amount can be used to partially fill the order.

### calculateQuoteAmount
`Order::calculateQuoteAmount(SomeWork\P2PPathFinder\Domain\Money\Money $baseAmount): SomeWork\P2PPathFinder\Domain\Money\Money`

Calculates the quote currency proceeds for the provided base amount.

### calculateEffectiveQuoteAmount
`Order::calculateEffectiveQuoteAmount(SomeWork\P2PPathFinder\Domain\Money\Money $baseAmount): SomeWork\P2PPathFinder\Domain\Money\Money`

Calculates the quote amount adjusted by the fee policy when present.

### calculateGrossBaseSpend
`Order::calculateGrossBaseSpend(SomeWork\P2PPathFinder\Domain\Money\Money $baseAmount, ?SomeWork\P2PPathFinder\Domain\Order\Fee\FeeBreakdown $feeBreakdown = null): SomeWork\P2PPathFinder\Domain\Money\Money`

Calculates the total base asset required to fill the provided net amount.

## SomeWork\P2PPathFinder\Domain\Order\OrderBook

### Public methods

### __construct
`OrderBook::__construct(iterable $orders = [])`

Parameter $orders: iterable&lt;Order&gt;

### add
`OrderBook::add(SomeWork\P2PPathFinder\Domain\Order\Order $order): void`

Appends an order to the in-memory order book.

### getIterator
`OrderBook::getIterator(): Traversable`

Returns: Traversable&lt;int, Order&gt;

### filter
`OrderBook::filter(SomeWork\P2PPathFinder\Domain\Order\Filter\OrderFilterInterface ...$filters): Generator`

Returns: Generator&lt;int, Order&gt;



// Apply multiple filters to reduce order book size
$filtered = $orderBook->filter(
new MinimumAmountFilter(Money::fromString('BTC', '0.01', 8)),
new MaximumAmountFilter(Money::fromString('BTC', '10.0', 8))
);

// Filtered orders can be iterated or converted to array
$filteredOrders = iterator_to_array($filtered);
```

## SomeWork\P2PPathFinder\Domain\Order\OrderBounds
Represents inclusive lower/upper bounds for the fillable base asset amount of an order.

## Invariants

- **Currency consistency**: Min and max must share the same currency
- **Bounds ordering**: Min amount must not exceed max amount (min <= max)
- **Scale normalization**: Internal scale = max(min.scale, max.scale)
- **Inclusive bounds**: contains() checks min <= amount <= max (inclusive on both ends)

### Public methods

### from
`OrderBounds::from(SomeWork\P2PPathFinder\Domain\Money\Money $min, SomeWork\P2PPathFinder\Domain\Money\Money $max): self`

Constructs an order bounds instance after validating currency consistency.

### min
`OrderBounds::min(): SomeWork\P2PPathFinder\Domain\Money\Money`

Returns the minimum permissible base asset amount.

### max
`OrderBounds::max(): SomeWork\P2PPathFinder\Domain\Money\Money`

Returns the maximum permissible base asset amount.

### contains
`OrderBounds::contains(SomeWork\P2PPathFinder\Domain\Money\Money $amount): bool`

Checks whether the provided amount falls within the configured bounds.

### clamp
`OrderBounds::clamp(SomeWork\P2PPathFinder\Domain\Money\Money $amount): SomeWork\P2PPathFinder\Domain\Money\Money`

Clamps the provided amount to the bounds and returns the adjusted value.

## SomeWork\P2PPathFinder\Domain\Order\OrderSide
Order side enum (BUY or SELL).

### Public methods

### cases
`OrderSide::cases(): array`

### from
`OrderSide::from(string|int $value): static`

### tryFrom
`OrderSide::tryFrom(string|int $value): ?static`

## SomeWork\P2PPathFinder\Domain\Tolerance\DecimalTolerance
Immutable representation of a tolerance ratio expressed as a decimal value between 0 and 1.

### Public methods

### fromNumericString
`DecimalTolerance::fromNumericString(string $ratio, ?int $scale = null): self`

Parameter $ratio: numeric-string

### zero
`DecimalTolerance::zero(): self`

### ratio
`DecimalTolerance::ratio(): string`

Returns: numeric-string

### scale
`DecimalTolerance::scale(): int`

### isZero
`DecimalTolerance::isZero(): bool`

### compare
`DecimalTolerance::compare(string $value, ?int $scale = null): int`

Parameter $value: numeric-string

### isGreaterThanOrEqual
`DecimalTolerance::isGreaterThanOrEqual(string $value, ?int $scale = null): bool`

Parameter $value: numeric-string

### isLessThanOrEqual
`DecimalTolerance::isLessThanOrEqual(string $value, ?int $scale = null): bool`

Parameter $value: numeric-string

### percentage
`DecimalTolerance::percentage(int $scale = 2): string`

Converts the tolerance ratio to a percentage string.

Uses extra working precision during multiplication to minimize rounding loss
before scaling to the requested percentage scale with HALF_UP rounding.

Parameter $scale: int — The number of decimal places for the percentage result (default: 2)


Returns: numeric-string The tolerance as a percentage (e.g., "5.00" for 0.05 ratio at scale 2)

## SomeWork\P2PPathFinder\Domain\Tolerance\ToleranceWindow
Represents a normalized tolerance window with deterministic heuristics.

## Invariants

- **Tolerance range**: Both minimum and maximum must be in [0, 1) range
- **Bounds ordering**: Minimum must not exceed maximum (min <= max)
- **Canonical scale**: All tolerances normalized to 18 decimal places
- **Heuristic derivation**: heuristicTolerance = (min == max) ? min : max

### Public methods

### fromStrings
`ToleranceWindow::fromStrings(string $minimum, string $maximum): self`

### normalizeTolerance
`ToleranceWindow::normalizeTolerance(string $value, string $context): string`

Normalizes a tolerance value ensuring it lies within the [0, 1) interval.


Returns: numeric-string

### minimum
`ToleranceWindow::minimum(): string`

Returns the lower relative tolerance bound expressed as a fraction.

Returns: numeric-string

### maximum
`ToleranceWindow::maximum(): string`

Returns the upper relative tolerance bound expressed as a fraction.

Returns: numeric-string

### heuristicTolerance
`ToleranceWindow::heuristicTolerance(): string`

Returns the tolerance used by heuristic consumers when no override is supplied.

Returns: numeric-string

### heuristicSource
`ToleranceWindow::heuristicSource(): string`

Returns the source of the heuristic tolerance value.

Returns: 'minimum'|'maximum'

### scale
`ToleranceWindow::scale(): int`

## SomeWork\P2PPathFinder\Exception\ExceptionInterface
Marker interface implemented by all library-specific exceptions.

## SomeWork\P2PPathFinder\Exception\GuardLimitExceeded
Thrown when search guard rails are exceeded before a path can be materialised.

## SomeWork\P2PPathFinder\Exception\InfeasiblePath
Thrown when path materialisation fails due to unmet constraints.

## SomeWork\P2PPathFinder\Exception\InvalidInput
Thrown when a consumer supplies malformed or unsupported input.

## SomeWork\P2PPathFinder\Exception\PrecisionViolation
Thrown when deterministic arithmetic guarantees cannot be upheld.
